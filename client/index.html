<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Voice Chat</title>
    <style>
        body { font-family: Arial; margin: 20px; }
    </style>
</head>
<body>

<h2>LAN Voice Chat</h2>
<button onclick="startAudio()">Start Audio</button>

<script>
    let ws;
    let audioCtx;
    let workletNode;

    // Temporary buffer to accumulate PCM chunks for smoother audio
    let pcmBuffer = [];

    // Start WebSocket connection
    function startWS() {
        ws = new WebSocket("wss://172.27.128.250:8080");
        ws.binaryType = "arraybuffer";

        ws.onopen = () => console.log("Connected to server");

        ws.onmessage = (event) => {
            if (!(event.data instanceof ArrayBuffer)) return;
            playRawPCM(event.data);
        };
    }

    // Convert raw PCM to Float32 and play
    function playRawPCM(arrayBuffer) {
        const float32Array = new Float32Array(arrayBuffer.byteLength / 2);
        const view = new DataView(arrayBuffer);
        for (let i = 0; i < float32Array.length; i++) {
            float32Array[i] = view.getInt16(i*2, true) / 0x7fff;
        }

        const buffer = audioCtx.createBuffer(1, float32Array.length, audioCtx.sampleRate);
        buffer.getChannelData(0).set(float32Array);

        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.connect(audioCtx.destination);
        source.start();
    }

    // Start microphone capture
    async function startAudio() {
        if (!navigator.mediaDevices?.getUserMedia) {
            alert("Browser does not support microphone");
            return;
        }

        audioCtx = new AudioContext();
        if (audioCtx.state === 'suspended') await audioCtx.resume();

        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const source = audioCtx.createMediaStreamSource(stream);

        // Load AudioWorklet processor
        await audioCtx.audioWorklet.addModule('pcm-processor.js');
        workletNode = new AudioWorkletNode(audioCtx, 'pcm-processor');

        // Send PCM chunks to server (buffered)
        workletNode.port.onmessage = (e) => {
            pcmBuffer.push(new Uint8Array(e.data));
            // Send when buffer reaches ~4096 samples
            const totalBytes = pcmBuffer.reduce((sum, c) => sum + c.length, 0);
            if (totalBytes >= 4096*2) {
                const combined = new Uint8Array(totalBytes);
                let offset = 0;
                for (const chunk of pcmBuffer) {
                    combined.set(chunk, offset);
                    offset += chunk.length;
                }
                if (ws.readyState === WebSocket.OPEN) ws.send(combined.buffer);
                pcmBuffer = [];
            }
        };

        source.connect(workletNode).connect(audioCtx.destination);
    }
    startWS();
</script>

</body>
</html>
